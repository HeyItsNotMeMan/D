--// Services
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local VirtualUser = game:GetService("VirtualUser")

--// Player References
local player = Players.LocalPlayer
local backpack = player:WaitForChild("Backpack")
local bin = player:WaitForChild("bin")
local airValue = bin:WaitForChild("Air")
local toolActionRemote = ReplicatedStorage:WaitForChild("RS"):WaitForChild("Remotes"):WaitForChild("Misc"):WaitForChild("ToolAction")
local openChestRemote = ReplicatedStorage:WaitForChild("RS"):WaitForChild("Remotes"):WaitForChild("Misc"):WaitForChild("OpenChest")

--// Config
local foodItems = {"Red apple", "Banana", "Grapes", "Orange", "Green apple"}
local surfaceY = 415
local flySpeed = 50
local spotTp = 250
local tweenSpeed = 200
local chestSpeed = 60
local spotResetTime = 1200 -- seconds

--// Delete Folders
for _, name in ipairs({"Enemies", "Effects"}) do
    local folder = Workspace:FindFirstChild(name)
    if folder then folder:Destroy() end
end

local map = Workspace:FindFirstChild("Map")
if map then
    local weather = map:FindFirstChild("Weather")
    if weather then weather:Destroy() end
end

--// Anti-AFK
player.Idled:Connect(function()
    VirtualUser:Button2Down(Vector2.zero, workspace.CurrentCamera.CFrame)
    task.wait(1)
    VirtualUser:Button2Up(Vector2.zero, workspace.CurrentCamera.CFrame)
end)

--// Auto Eat
task.spawn(function()
    while true do
        for _, name in ipairs(foodItems) do
            local tool = backpack:FindFirstChild(name)
            if tool then
                toolActionRemote:FireServer(tool)
            end
        end
        task.wait(60)
    end
end)

--// Helper: Get Alive Character
local function getAliveCharacter()
    local char = player.Character
    local humanoid = char and char:FindFirstChildOfClass("Humanoid")
    while not char or not humanoid or humanoid.Health <= 0 do
        player.CharacterAdded:Wait()
        char = player.Character
        humanoid = char and char:FindFirstChildOfClass("Humanoid")
        task.wait(0.1)
    end
    return char, humanoid, char:WaitForChild("HumanoidRootPart")
end

--// Noclip
local Clip = false
local NoclipConnection
local function startNoclip(character)
    NoclipConnection = RunService.Stepped:Connect(function()
        if not Clip and character then
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") and part.CanCollide and part.Name ~= "floatName" then
                    part.CanCollide = false
                end
            end
        end
    end)
end

--// Fly
local control = {F = 0, B = 0, L = 0, R = 0}
local bodyGyro, bodyVelocity

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.W then control.F = 1 end
    if input.KeyCode == Enum.KeyCode.S then control.B = -1 end
    if input.KeyCode == Enum.KeyCode.A then control.L = -1 end
    if input.KeyCode == Enum.KeyCode.D then control.R = 1 end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.W then control.F = 0 end
    if input.KeyCode == Enum.KeyCode.S then control.B = 0 end
    if input.KeyCode == Enum.KeyCode.A then control.L = 0 end
    if input.KeyCode == Enum.KeyCode.D then control.R = 0 end
end)

local function startFlying(hrp)
    if bodyGyro then bodyGyro:Destroy() end
    if bodyVelocity then bodyVelocity:Destroy() end

    bodyGyro = Instance.new("BodyGyro", hrp)
    bodyGyro.P = 9e4
    bodyGyro.maxTorque = Vector3.new(9e9, 9e9, 9e9)
    bodyGyro.CFrame = hrp.CFrame

    bodyVelocity = Instance.new("BodyVelocity", hrp)
    bodyVelocity.Velocity = Vector3.zero
    bodyVelocity.maxForce = Vector3.new(9e9, 9e9, 9e9)

    RunService:BindToRenderStep("Flying", Enum.RenderPriority.Input.Value, function()
        local cam = workspace.CurrentCamera
        local move = (cam.CFrame.RightVector * (control.R + control.L) + cam.CFrame.LookVector * (control.F + control.B))
        move = Vector3.new(move.X, 0, move.Z)
        bodyVelocity.Velocity = move.Magnitude > 0 and move.Unit * flySpeed or Vector3.zero
        bodyGyro.CFrame = cam.CFrame
    end)
end

--// Tween Helpers
local function returnToSurface(hrp)
    local target = Vector3.new(hrp.Position.X, surfaceY, hrp.Position.Z)
    local distance = (hrp.Position - target).Magnitude
    local tween = TweenService:Create(hrp, TweenInfo.new(distance / 100, Enum.EasingStyle.Linear), {CFrame = CFrame.new(target)})
    tween:Play()
    tween.Completed:Wait()
end

local function tweenToPosition(hrp, targetPos, speed)
    if airValue.Value < 10 then
        returnToSurface(hrp)
        repeat task.wait(1) until airValue.Value >= 100
    end

    local distance = (hrp.Position - targetPos).Magnitude
    local tween = TweenService:Create(hrp, TweenInfo.new(distance / speed, Enum.EasingStyle.Linear), {CFrame = CFrame.new(targetPos)})
    local completed = false
    tween.Completed:Connect(function() completed = true end)
    tween:Play()

    while not completed do
        if airValue.Value < 10 then
            tween:Cancel()
            returnToSurface(hrp)
            repeat task.wait(1) until airValue.Value >= 100
            return false
        end
        task.wait()
    end

    return true
end

--// Spot Finder
local function findNearestSpot(hrp)
    local seaContent = Workspace:FindFirstChild("Map") and Workspace.Map:FindFirstChild("SeaContent")
    if not seaContent then return end

    local validNames = {["DivingSpot"] = true, ["ObolusSpot"] = true, ["UWStructure"] = true}
    local closest, shortest = nil, math.huge

    for _, model in ipairs(seaContent:GetChildren()) do
        if model.Name ~= "None" and validNames[model.Name] and model:IsA("Model") and model:FindFirstChild("Base") then
            local dist = (hrp.Position - model.Base.Position).Magnitude
            if dist < shortest then
                shortest = dist
                closest = model
            end
        end
    end

    return closest
end

--// Main Loop
local function mainLoop()
    local character, humanoid, hrp = getAliveCharacter()
    startNoclip(character)
    startFlying(hrp)

    while true do
        if not character or not character.Parent or not humanoid or humanoid.Health <= 0 then
            character, humanoid, hrp = getAliveCharacter()
            startFlying(hrp)
            task.wait(2)
        end

        tweenToPosition(hrp, Vector3.new(hrp.Position.X, surfaceY, hrp.Position.Z), tweenSpeed)

        local spot = findNearestSpot(hrp)
        if not spot then task.wait(1) continue end

        local base = spot:FindFirstChild("Base")
        if not base then task.wait(1) continue end

        -- Teleport above spot
        local aboveSpot = Vector3.new(base.Position.X, surfaceY, base.Position.Z)
        local dist = (hrp.Position - aboveSpot).Magnitude
        task.wait(dist / spotTp)
        hrp.CFrame = CFrame.new(aboveSpot)

        -- Spot Deactivation
        local originalName = spot.Name
        spot.Name = "None"
        task.delay(spotResetTime, function()
            if spot and spot.Parent and spot.Name == "None" then
                spot.Name = originalName
            end
        end)

        -- Destroy "Details" if it exists
        local details = spot:WaitForChild("Details", 20)
        if details then details:Destroy() end

        -- Chest Handling
        local chests = spot:WaitForChild("Chests", 5)
        if chests then
            while true do
                local unopened = {}
                for _, chest in ipairs(chests:GetChildren()) do
                    if chest:IsA("Model") and chest:FindFirstChild("Base") and not chest:FindFirstChild("Open") then
                        table.insert(unopened, chest)
                    end
                end

                if #unopened == 0 then break end

                table.sort(unopened, function(a, b)
                    return (hrp.Position - a.Base.Position).Magnitude < (hrp.Position - b.Base.Position).Magnitude
                end)

                local nearest = unopened[1]
                if tweenToPosition(hrp, nearest.Base.Position, chestSpeed) then
                    openChestRemote:FireServer(nearest)
                    task.wait(0.1)
                end
            end
        end
    end
end

mainLoop()
